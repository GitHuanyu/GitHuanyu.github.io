{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"陈环宇","url":"https://githuanyu.github.io"},"pages":[{"title":"categories","date":"2018-05-15T07:43:42.000Z","updated":"2018-05-16T06:19:53.440Z","comments":true,"path":"categories/index.html","permalink":"https://githuanyu.github.io/categories/index.html","excerpt":"","text":"JS插件方便实现一些特效的好用的组件hexo搭建博客的方法，命令行，目录结构闲聊和技术不想关的内容"},{"title":"about","date":"2018-05-15T07:30:29.000Z","updated":"2018-05-16T06:11:57.885Z","comments":true,"path":"about/index.html","permalink":"https://githuanyu.github.io/about/index.html","excerpt":"","text":"自我介绍，无名小站"},{"title":"tags","date":"2018-05-15T07:43:30.000Z","updated":"2018-05-15T07:43:30.207Z","comments":true,"path":"tags/index.html","permalink":"https://githuanyu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"http协议","slug":"http协议","date":"2018-06-29T02:52:18.000Z","updated":"2018-06-29T03:53:44.531Z","comments":true,"path":"2018/06/29/http协议/","link":"","permalink":"https://githuanyu.github.io/2018/06/29/http协议/","excerpt":"","text":"HTTP协议客户端和服务端进行数据传输的一种规则 URLhttp url包含了用于查找某个资源的详细信息,格式如下1http://host[&quot;:&quot;port][abs_path] http表示要通过HTTP协议来定位网络资源，host表示合法的Internet主机域名或者IP地址，port指定一个端口号，为空则使用缺省端口80，abs_path指定请求资源的URI。 HTTP请求 请求行请求行由请求方法，URL字段和HTTP协议版本三部分构成，总的来说请求行就是定义了本次请求的请求方式，请求的地址，以及所遵循的HTTP协议版本例如：1GET /example.html HTTP/1.1 (CRLF) 方法 描述 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 请求头请求头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息 信息 描述 举例 Accept 指定客户端接受哪些类型的信息 Accept：image/gif，表明客户端希望接受GIF图象格式的资源 Accept-Charset 指定客户端接受的字符集 Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受 Accept-Encoding 类似于Accept，但是它是用于指定可接受的内容编码 Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受 Accept-Language 类似于Accept，但是它是用于指定一种自然语言 Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受 Authorization 用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证 Host 发送请求时，该报头域是必需的,Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 User-Agent 我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了 请求正文只有在发送post请求时才会有请求正文，get方法并没有请求正文","categories":[{"name":"辅助","slug":"辅助","permalink":"https://githuanyu.github.io/categories/辅助/"}],"tags":[{"name":"web","slug":"web","permalink":"https://githuanyu.github.io/tags/web/"}]},{"title":"webpack入门","slug":"webpack入门","date":"2018-05-24T07:40:26.000Z","updated":"2018-05-24T07:43:47.560Z","comments":true,"path":"2018/05/24/webpack入门/","link":"","permalink":"https://githuanyu.github.io/2018/05/24/webpack入门/","excerpt":"","text":"本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。","categories":[{"name":"辅助","slug":"辅助","permalink":"https://githuanyu.github.io/categories/辅助/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://githuanyu.github.io/tags/webpack/"}]},{"title":"基本类型和引用类型","slug":"基本类型和引用类型","date":"2018-05-23T06:55:29.000Z","updated":"2018-05-23T07:40:42.390Z","comments":true,"path":"2018/05/23/基本类型和引用类型/","link":"","permalink":"https://githuanyu.github.io/2018/05/23/基本类型和引用类型/","excerpt":"","text":"基本数据类型 引用数据类型 简单的数据段 多个值构成的对象 按值访问 按内存地址访问，操作对象实际上是操作对象的引用 值指的是，而引用数据类型值指的是那些可能由。 12345//Function对象（类）var foo = new Function(\"a\", \"b\", \"alert(a + b);\");foo(1, 5);//由于字符串的关系，这种形式写起来很困难，但是说明了函数只不过是一种引用类型//它的行为与用Function类明确创建的函数行为是相同的 引用类型通常叫做类，遇到引用值，所处理的就是对象 基本类型基本类型 Number Boolean String undefined null基本类型的数据存放在栈内存中基本类型的复制就是在栈内存中开辟了一个新的存储区域来存储新的变量，这个变量有他自己的值，只不过和前面的值一样，所以如果其中一个值改变了不会影响到另一个 引用类型引用类型 Object Function引用类型的数据存放在堆内存中定义了一个对象其实是在栈内存中存储了一个指针，这个指针指向堆内存中该对象的存储地址，复制给另一个对象的过程其实是把该对象的地址复制给了另一个对象变量，两个指针都指向同一个对象，如果其中一个修改了，另一个也会改变 基本类型的数据是没有属性和方法的，引用类型才有，但是为什么String类型有方法呢？var string = ‘aaa’;var string2 = string.substring(0);基本类型的确没有方法和属性，因为一旦创建了属性或者方法就会被立刻销毁，但是为了方便对基本类型数据进行操作，在底层做了一些工作，其实这段代码相当于var string = new String(‘aaa’);var string2 = string.substring(0);string = null; 1.创建了一个String类型的实例，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的瞬间，然后立即被销毁2.在实例上调用指定方法3.销毁该实例 经过这三步，字符串值就变得和对象一样了，在Boolean，Number中也是一样String, Boolean, Number 这三种类型也叫做 基本包装类型","categories":[{"name":"JS高级","slug":"JS高级","permalink":"https://githuanyu.github.io/categories/JS高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"JS时间戳","slug":"JS时间戳","date":"2018-05-23T03:02:52.000Z","updated":"2018-05-23T06:32:26.502Z","comments":true,"path":"2018/05/23/JS时间戳/","link":"","permalink":"https://githuanyu.github.io/2018/05/23/JS时间戳/","excerpt":"","text":"获取当前时间戳123var timestamp1 = Date.parse(new Date());var timestamp2 = (new Date()).valueOf();var timestamp3 = new Date().getTime(); 获取指定时间戳1var oldTime = (new Date(\"2015/06/23 08:00:20\")).getTime()/1000;","categories":[{"name":"JS高级","slug":"JS高级","permalink":"https://githuanyu.github.io/categories/JS高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"jquery-form","slug":"jquery-form","date":"2018-05-23T02:37:49.000Z","updated":"2018-05-23T06:34:52.020Z","comments":true,"path":"2018/05/23/jquery-form/","link":"","permalink":"https://githuanyu.github.io/2018/05/23/jquery-form/","excerpt":"","text":"异步提交表单 (引入jquery.form.min.js)项目地址https://github.com/jquery-form/form ajaxForm( options )通过submit的button直接提交1234// prepare all forms for ajax submission$('form').ajaxForm(&#123; target: '#myResultsDiv'&#125;); ajaxSubmit( options )通过提交的事件触发1234567// bind submit handler to form$('form').on('submit', function(e) &#123; e.preventDefault(); // prevent native submit $(this).ajaxSubmit(&#123; target: 'myResultsDiv' &#125;)&#125;);","categories":[{"name":"JS插件","slug":"JS插件","permalink":"https://githuanyu.github.io/categories/JS插件/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://githuanyu.github.io/tags/jQuery/"}]},{"title":"VUE计算属性","slug":"VUE计算属性","date":"2018-05-22T02:24:30.000Z","updated":"2018-05-22T02:30:05.558Z","comments":true,"path":"2018/05/22/VUE计算属性/","link":"","permalink":"https://githuanyu.github.io/2018/05/22/VUE计算属性/","excerpt":"","text":"computed12345678910111213var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;) 声明了一个计算属性 reversedMessage 。提供的函数将用作属性 vm.reversedMessage 的 getter 。vm.reversedMessage 依赖于 vm.message，在 vm.message 发生改变时，vm.reversedMessage 也会更新。 我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。","categories":[{"name":"VUE","slug":"VUE","permalink":"https://githuanyu.github.io/categories/VUE/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"VUE生命周期","slug":"VUE生命周期","date":"2018-05-18T08:00:12.000Z","updated":"2018-05-22T02:22:34.924Z","comments":true,"path":"2018/05/18/VUE生命周期/","link":"","permalink":"https://githuanyu.github.io/2018/05/18/VUE生命周期/","excerpt":"","text":"创建=》挂载=》更新=》销毁类似于一种回调，在执行到一定的阶段时触发，扔出一个钩子，让需要在此阶段执行的方法调用 beforeCreate创建vue对象，methods和data属性初始化到vue对象之上 createdvue对象创建完成，进行数据初始化，可以发送ajax来对vue对象静态属性进行初始化 beforeMount通过虚拟dom(数据结构)来构造真实dom(html)，可以操作真实dom结构了 mounted将渲染出的真实dom挂载，是一个appendChild的过程 beforeUpdateupdatedbeforeDestroydestroyed 钩子 特性 beforeCreate none created data beforeMount el mounted data+el","categories":[{"name":"VUE","slug":"VUE","permalink":"https://githuanyu.github.io/categories/VUE/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"JS模块化","slug":"JS模块化","date":"2018-05-17T09:01:24.000Z","updated":"2018-05-18T02:48:05.078Z","comments":true,"path":"2018/05/17/JS模块化/","link":"","permalink":"https://githuanyu.github.io/2018/05/17/JS模块化/","excerpt":"","text":"ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块主要有两个功能：export和import export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口 import用于在一个模块中加载另一个含有export接口的模块。 export1.使用大括号指定所要输出的一组变量12345// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 2.输出函数或类1234// profile.jsexport function multiply(x, y) &#123; return x * y;&#125;; import1.单独加载1234import &#123;firstName, lastName, year&#125; from './profile.js';import &#123;foo&#125; from 'my_module';foo(); 2.整体加载即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 12345678910111213// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;//////////////import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); export default其他模块加载该模块时，import命令可以为该匿名函数指定任意名字这时import命令后面，不使用大括号一个模块只能有一个默认输出 1234567// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport customName from './export-default';customName(); // 'foo' export default也可以用来输出类123456// MyClass.jsexport default class &#123; ... &#125;// main.jsimport MyClass from 'MyClass';let o = new MyClass();","categories":[{"name":"JS高级","slug":"JS高级","permalink":"https://githuanyu.github.io/categories/JS高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"构造函数的继承","slug":"构造函数的继承","date":"2018-05-17T02:15:58.000Z","updated":"2018-05-17T07:03:34.094Z","comments":true,"path":"2018/05/17/构造函数的继承/","link":"","permalink":"https://githuanyu.github.io/2018/05/17/构造函数的继承/","excerpt":"","text":"12345678function Animal()&#123; this.species = '动物';&#125;function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 如何使Cat()继承Animal()???如果Cat()的prototype对象，指向一个Animal()的实例，那么所有Cat()的实例，就能继承Animal() 1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 line1将Cat的prototype对象指向了一个Animal()的实例，它相当于完全删除了prototype对象原先的值，然后赋予一个新值 1234567891011121314// 这是Cat原先的prototype对象&#123; constructor: Cat, // 任何一个prototype对象都有一个constructor属性，指向它的构造函数&#125; // 指向Animal()实例后的新prototype对象&#123; species: '动物', prototype: &#123; constructor: Animal &#125; // 每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性&#125; line2此时Cat()的实例的 constructor 会指向 Animal()，会导致继承链的紊乱，需要手动纠正 1234// 如果替换了prototype对象o.prototype = &#123;&#125;;// 下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。o.prototype.constructor = o;","categories":[{"name":"JS高级","slug":"JS高级","permalink":"https://githuanyu.github.io/categories/JS高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"prototype的设定由来","slug":"prototype的设定由来","date":"2018-05-16T09:30:08.000Z","updated":"2018-05-17T02:26:34.736Z","comments":true,"path":"2018/05/16/prototype的设定由来/","link":"","permalink":"https://githuanyu.github.io/2018/05/16/prototype的设定由来/","excerpt":"","text":"在js语言中，new命令之后跟的不是类，而是构造函数 对构造函数使用 new，会生成一个对象的实例 构造函数中的 this 关键字，它代表新创建的实例对象 但是用构造函数生成实例对象，有一个缺点，就是无法共享属性和方法 12345678910function Dog(name)&#123; this.name = name; this.species = '犬科';&#125;var dogA = new Dog('AA');var dogB = new Dog('BB');dogA.species = '猫科';alert(dogB.species); //显示 犬科，而不会受到dogA的影响 此时dogA和dogB会自动含有一个 constructor 属性，指向它们的构造函数1dogA.constructot == Dog 考虑到这一点，构造函数有了一个 prototype 属性 12345678910function Dog(name)&#123; this.name = name;&#125;Dog.prototype = &#123; species : '犬科' &#125;;var dogA = new Dog('大毛');var dogB = new Dog('二毛');alert(dogA.species); // 犬科alert(dogB.species); // 犬科 这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。 实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。 现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。 1234567Dog.prototype.species = '猫科';Dog.prototype.eat = function()&#123; alert('我在吃');&#125;alert(dogA.species); // 猫科alert(dogB.species); // 猫科 此时实例中的species属性和eat()方法，其实都是一个内存地址，指向prototype对象，因此提高了运行效率","categories":[{"name":"JS高级","slug":"JS高级","permalink":"https://githuanyu.github.io/categories/JS高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"animate.css","slug":"animate-css","date":"2018-05-16T05:47:25.000Z","updated":"2018-05-16T05:57:26.660Z","comments":true,"path":"2018/05/16/animate-css/","link":"","permalink":"https://githuanyu.github.io/2018/05/16/animate-css/","excerpt":"","text":"A cross-browser library of CSS animations项目地址https://github.com/daneden/animate.css 演示地址https://daneden.github.io/animate.css/ 12345678910111213141516171819//为元素添加动画效果$('#yourElement').addClass('animated bounceOutLeft');or$('#yourElement').animateCss('bounce');//添加动画执行之后的回调$('#yourElement').animateCss('bounce', function() &#123; // Do somthing after animation&#125;);//调整动画执行的参数#yourElement &#123; //持续时间 -vendor-animation-duration: 3s; //延迟多久后执行 -vendor-animation-delay: 2s; //执行次数 -vendor-animation-iteration-count: infinite;&#125;","categories":[{"name":"JS插件","slug":"JS插件","permalink":"https://githuanyu.github.io/categories/JS插件/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://githuanyu.github.io/tags/jQuery/"}]},{"title":"Notyf","slug":"Notyf","date":"2018-05-16T03:28:05.000Z","updated":"2018-05-16T03:37:19.722Z","comments":true,"path":"2018/05/16/Notyf/","link":"","permalink":"https://githuanyu.github.io/2018/05/16/Notyf/","excerpt":"","text":"Notyf is a dead simple, responsive, vanilla javascript notification plugin. No jQuery required.项目地址https://github.com/caroso1222/notyf 123456789101112131415//实例化var notyf = new Notyf();//实例化传入配置参数var notyf = new Notyf(&#123; delay:1000, alertIcon: 'fa fa-exclamation-circle', confirmIcon: 'fa fa-check-circle' &#125;)//警告弹框，红色notyf.alert('aaa');//通知弹框，绿色notyf.confirm('bbb');","categories":[{"name":"JS插件","slug":"JS插件","permalink":"https://githuanyu.github.io/categories/JS插件/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://githuanyu.github.io/tags/javascript/"}]},{"title":"jqPaginator","slug":"jqPaginator","date":"2018-05-16T03:05:47.000Z","updated":"2018-05-16T03:38:21.592Z","comments":true,"path":"2018/05/16/jqPaginator/","link":"","permalink":"https://githuanyu.github.io/2018/05/16/jqPaginator/","excerpt":"","text":"基于jquery的分页组件项目地址https://github.com/keenwon/jqPaginator 演示地址http://jqpaginator.keenwon.com/ 12345678&lt;ul class=\"pagination\" id=\"pagination\"&gt;&lt;/ul&gt;$('#pagination').jqPaginator(&#123; totalPages: 100, visiblePages: 10, currentPage: 1, onPageChange: function(num, type) &#123; &#125;&#125;);","categories":[{"name":"JS插件","slug":"JS插件","permalink":"https://githuanyu.github.io/categories/JS插件/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://githuanyu.github.io/tags/jQuery/"}]},{"title":"hexo命令","slug":"hexo命令","date":"2018-05-15T08:10:21.000Z","updated":"2018-05-16T03:12:15.867Z","comments":true,"path":"2018/05/15/hexo命令/","link":"","permalink":"https://githuanyu.github.io/2018/05/15/hexo命令/","excerpt":"","text":"123456789101112131415161718192021222324npm install hexo-cli -gnpm install hexo --savehexo init//进入空白文件夹搭建脚手架，生成hexo项目框架hexo g//generate新的文件关系hexo s//server本地展示hexo d // 部署到github.iohexo d -g//在部署前先生成npm install hexo-deployer-git --save//安装扩展，否则 deloyer not found:githexo new post &quot;article title&quot;//发布新文章","categories":[{"name":"hexo","slug":"hexo","permalink":"https://githuanyu.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://githuanyu.github.io/tags/hexo/"},{"name":"cmd","slug":"cmd","permalink":"https://githuanyu.github.io/tags/cmd/"}]},{"title":"first demo","slug":"first-demo","date":"2018-05-15T03:11:15.000Z","updated":"2018-05-16T01:14:54.671Z","comments":true,"path":"2018/05/15/first-demo/","link":"","permalink":"https://githuanyu.github.io/2018/05/15/first-demo/","excerpt":"","text":"人在杭州已经叠甲十年","categories":[{"name":"闲聊","slug":"闲聊","permalink":"https://githuanyu.github.io/categories/闲聊/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-05-14T16:00:00.000Z","updated":"2018-05-16T03:12:14.116Z","comments":true,"path":"2018/05/15/hello-world/","link":"","permalink":"https://githuanyu.github.io/2018/05/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://githuanyu.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://githuanyu.github.io/tags/hexo/"},{"name":"cmd","slug":"cmd","permalink":"https://githuanyu.github.io/tags/cmd/"}]}]}